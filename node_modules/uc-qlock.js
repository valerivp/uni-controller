'use strict';

module.exports.version = '0.0.1';

module.exports.queue = function(name, len) {
    this.locks = [];

    this.lock = function (options) {
        let handle = {};
        //handle.date = Date.now();
        let $this = this;
        if (this.locks.length >= len)
            handle.promise = Promise.reject(new Error('Queue length exceeded'));
        else if (!this.locks.length) {
            //console.warn('lock');
            handle.promise = Promise.resolve();
            this.locks.push(handle);
        } else {
            //console.warn('wait');
            this.locks.push(handle);
            handle.promise = new Promise(function (resolve, reject) {
                if ((options || {}).timeout)
                    handle.timeout = setTimeout((function (h, cb_reject) {
                            clearInterval(h.interval);
                            h.interval = undefined;
                            cb_reject(new Error(`lock timeout: ${name}`));
                            let i = this.locks.indexOf(h);
                            if (i >= 0)
                                this.locks.splice(i, 1);
                            else
                                throw new Error('Promise item not found');
                        }).bind($this, handle, reject),
                        options.timeout);
                handle.interval = setInterval((function (h, cb_resolve) {
                    let i = this.locks.indexOf(h);
                    if (i === 0) {
                        //console.warn('lock after wait');
                        clearInterval(h.interval);
                        h.interval = undefined;
                        clearTimeout(h.timeout);
                        h.timeout = undefined;
                        cb_resolve(); // переведёт промис в состояние fulfilled
                    } else if (i < 0) {
                        throw new Error('Promise item not found');
                    }
                }).bind($this, handle, resolve), 1);
            });
        }
        return handle.promise;
    };

    this.unlock = function() {
        this.locks.splice(0, 1);
    };

};
